///*
// * UART.c
// *
// *  Created on: 2024. 6. 27.
// *      Author: USER
// */
//
//#include "IfxAsclin_Asc.h"
//#include "IfxCpu_Irq.h"
//#include <stdio.h>
//#include "IfxStdIf_DPipe.h"
//#include "isr_priority.h"
//
//// 버퍼 크기 및 보드레이트 정의
//#define ASC_TX_BUFFER_SIZE 256
//#define ASC_RX_BUFFER_SIZE 256
//#define ASC_BAUDRATE 115200
//#define TOF_BAUDRATE 921600
//#define BLUETOOTH_BAUDRATE 9600
//
//// 표준 인터페이스 객체
////static IfxAsclin_Asc g_ascHandle0;
////static IfxAsclin_Asc g_ascHandle1;
//static IfxAsclin_Asc g_ascHandle3;
//static IfxStdIf_DPipe g_ascStandardInterface;
//
//// 데이터 및 FIFO 런타임 변수를 위한 전송 버퍼
//uint8 g_uartTxBuffer[ASC_TX_BUFFER_SIZE + sizeof(Ifx_Fifo) + 8];
//uint8 g_uartRxBuffer[ASC_RX_BUFFER_SIZE + sizeof(Ifx_Fifo) + 8];
//
//IFX_INTERRUPT(asclin3TxISR, 0, ISR_PRIORITY_ASCLIN_TX);
//void asclin3TxISR(void)
//{
//    IfxAsclin_Asc_isrTransmit(&g_ascHandle3);
//}
//
//IFX_INTERRUPT(asclin3RxISR, 0, ISR_PRIORITY_ASCLIN_RX);
//void asclin3RxISR(void)
//{
//    IfxAsclin_Asc_isrReceive(&g_ascHandle3);
//}
//
//IFX_INTERRUPT(asclin3ErrISR, 0, ISR_PRIORITY_ASCLIN_ER);
//void asclin3ErrISR(void)
//{
//    IfxAsclin_Asc_isrError(&g_ascHandle3);
//}
//
//void _init_uart3(void)
//{
//    IfxAsclin_Asc_Config ascConf;
//    IfxAsclin_Asc_initModuleConfig(&ascConf, &MODULE_ASCLIN3);
//
//    // 원하는 보드레이트 설정
//    ascConf.baudrate.baudrate = ASC_BAUDRATE;
//    ascConf.baudrate.oversampling = IfxAsclin_OversamplingFactor_16;
//
//    // 샘플링 모드 설정
//    ascConf.bitTiming.medianFilter = IfxAsclin_SamplesPerBit_three;
//    ascConf.bitTiming.samplePointPosition = IfxAsclin_SamplePointPosition_8;
//
//    // ISR 우선순위 및 인터럽트 타겟 설정
//    ascConf.interrupt.txPriority = ISR_PRIORITY_ASCLIN_TX;
//    ascConf.interrupt.rxPriority = ISR_PRIORITY_ASCLIN_RX;
//    ascConf.interrupt.erPriority = ISR_PRIORITY_ASCLIN_ER;
//    ascConf.interrupt.typeOfService = IfxSrc_Tos_cpu0;
//
//    // 핀 설정
//    const IfxAsclin_Asc_Pins pins = {
//        .cts = NULL_PTR, // CTS 핀 사용 안 함
//        .ctsMode = IfxPort_InputMode_pullUp,
//        .rx = &IfxAsclin3_RXD_P32_2_IN, // RX 핀
//        .rxMode = IfxPort_InputMode_pullUp,
//        .rts = NULL_PTR, // RTS 핀 사용 안 함
//        .tx = &IfxAsclin3_TX_P15_7_OUT, // TX 핀
//        .txMode = IfxPort_OutputMode_pushPull,
//        .pinDriver = IfxPort_PadDriver_cmosAutomotiveSpeed1
//    };
//    ascConf.pins = &pins;
//
//    /* FIFO 버퍼 설정 */
//    ascConf.txBuffer = g_uartTxBuffer;
//    ascConf.txBufferSize = ASC_TX_BUFFER_SIZE;
//    ascConf.rxBuffer = g_uartRxBuffer;
//    ascConf.rxBufferSize = ASC_RX_BUFFER_SIZE;
//
//    /* ASCLIN 모듈 초기화 */
//    IfxAsclin_Asc_initModule(&g_ascHandle3, &ascConf);
//
//    /* 표준 인터페이스 초기화 */
//    IfxAsclin_Asc_stdIfDPipeInit(&g_ascStandardInterface, &g_ascHandle3);
//
//    /* 콘솔 초기화 */
//    //Ifx_Console_init(&g_ascStandardInterface);
//}
//
//
//void _out_uart3(const unsigned char chr)
//{
//    while (IfxAsclin_Asc_canWriteCount(&g_ascHandle3, 1, TIME_INFINITE) != TRUE);
//    IfxAsclin_Asc_blockingWrite(&g_ascHandle3, chr);
//}
//
///* 시리얼 라인에서 문자를 수신 (대기) */
//unsigned char _in_uart3(void)
//{
//    return IfxAsclin_Asc_blockingRead(&g_ascHandle3);
//}
//
//
//
//








/*
 * uart.c
 *
 *  Created on: 2024. 6. 27.
 *      Author: USER
 */


#include "IfxAsclin_Asc.h"
#include "IfxCpu_Irq.h"                     //cpu 인터럽트 설정 및 관리
#include <stdio.h>                          //standard i/o
#include "IfxStdIf_DPipe.h"                 //표준 데이터 파이프 인터페이스
#include "uart.h"                           //내가 만든 uart header, IfxAsclin_Asc 포함
//#include "Ifx_Console.h"                    //Console ->
/******************************************************************************/

//송수신에 필요한 parameter들
#define ISR_PRIORITY_ASCLIN_TX      50      //인터럽트 우선순위 - 송신
#define ISR_PRIORITY_ASCLIN_RX      36      //인터럽트 우선순위 - 수신
#define ISR_PRIORITY_ASCLIN_ER      51      //인터럽트 우선순위 - 에러
#define ASC_TX_BUFFER_SIZE          256     //송신 버퍼 사이즈
#define ASC_RX_BUFFER_SIZE          256     //수신 버퍼 사이즈
#define ASC_BAUDRATE                115200  //baudrate 설정

//handler 정의
static IfxAsclin_Asc g_ascHandle3;
static IfxStdIf_DPipe g_ascStandardInterface;


/*
* 전송 버퍼는 데이터 자체와 FIFO 런타임 변수에 대해 메모리를 할당합니다.
* 버퍼가 위치한 주소에서 독립적인 적절한 원형 버퍼 처리를 보장하기 위해
* 8바이트를 추가해야 합니다
* 즉 전송 버퍼를 위한 추가 버퍼를 Ifx_Fifo 크기에 8만큼 더해서 추가해줍니다!
*/
uint8 g_uartTxBuffer[ASC_TX_BUFFER_SIZE + sizeof(Ifx_Fifo) + 8];
uint8 g_uartRxBuffer[ASC_RX_BUFFER_SIZE + sizeof(Ifx_Fifo) + 8];


//인터럽트의 정의, asyncronous Tx Interupt 함수를 0번 cpu로 ISR_..._TX의 우선순위에 맞추어 실행
IFX_INTERRUPT(asc0TxISR, 0, ISR_PRIORITY_ASCLIN_TX);
void asc0TxISR(void){
//    //DPipe를 통해 표준 인터페이스 송신
//    IfxStdIF_DPipe_onTransmit(&g_ascStandardInterface);
    IfxAsclin_Asc_isrTransmit(&g_ascHandle3);
}

//인터럽트의 정의, asyncronous Rx Interupt 함수를 0번 cpu로 ISR_..._RX의 우선순위에 맞추어 실행
IFX_INTERRUPT(asc0RxISR, 0, ISR_PRIORITY_ASCLIN_RX);
void asc0RxISR(void){
//    //DPipe를 통해 표준 인터페이스 수신
//    IfxStdIF_DPipe_onReceive(&g_ascStandardInterface);
    IfxAsclin_Asc_isrReceive(&g_ascHandle3);
}

//인터럽트의 정의, asyncronous ERROR Interupt 함수를 0번 cpu로 ISR_..._ER의 우선순위에 맞추어 실행
IFX_INTERRUPT(asc0ErrISR, 0, ISR_PRIORITY_ASCLIN_ER);
void asc0ErrISR(void){
//    //DPipe를 통해 표준 인터페이스 송신
//    IfxStdIF_DPipe_onError(&g_ascStandardInterface);
    while(1);
}


/* serial 선을 통해 UART 통신 연결하기 위한 함수
 * configuration을 선언, 설정한 뒤 할당해주고
 * 각 핀의 값을 설정한 뒤
 * 송, 수신 버퍼를 정해준 뒤
 * ASCLIN 모듈 통신 initiate, DPipe initiate, Console initiate 해줌
 */

void _init_uart3(void){
    IfxAsclin_Asc_Config ascConf;

    IfxAsclin_Asc_initModuleConfig(&ascConf, &MODULE_ASCLIN3); /* Initialize the structure with default values      */

    /* 기존에 정해둔 BaudRate로 재정의
     * 기존에 정해둔 BaudRate값은 uart.h에 정의되어있음
     */
    ascConf.baudrate.baudrate = ASC_BAUDRATE;                                   /* Baud Rate 설정                     */
    ascConf.baudrate.oversampling = IfxAsclin_OversamplingFactor_16;            /* 오버 샘플링 펙터 설정                  */

    /* 샘플 주기 결정 */
    ascConf.bitTiming.medianFilter = IfxAsclin_SamplesPerBit_three;             /* Set the number of samples per bit*/
    ascConf.bitTiming.samplePointPosition = IfxAsclin_SamplePointPosition_8;    /* Set the first sample position    */

    /* 인터럽트 우선순위 및 and 인터럽트 대상 */
    ascConf.interrupt.txPriority = ISR_PRIORITY_ASCLIN_TX;  /* TX events 인터럽트 우선순위 설정           */
    ascConf.interrupt.rxPriority = ISR_PRIORITY_ASCLIN_RX;  /* RX events 인터럽트 우선순위 설정           */
    ascConf.interrupt.erPriority = ISR_PRIORITY_ASCLIN_ER;  /* Error events 인터럽트 우선순위 설정        */
    ascConf.interrupt.typeOfService = IfxSrc_Tos_cpu0;

    /* Pin 설정 */
    const IfxAsclin_Asc_Pins pins = {
            .cts        = NULL_PTR,                         /* CTS pin not used                                            */
            .ctsMode    = IfxPort_InputMode_pullUp,
            .rx         = &IfxAsclin3_RXD_P32_2_IN ,        /* 통신용 pinmap header에 정의되어있는 15.7의 RX, USB port에 연결됨     */
            .rxMode     = IfxPort_InputMode_pullUp,         /* RX pin                                               */
            .rts        = NULL_PTR,                         /* RTS pin not used                                     */
            .rtsMode    = IfxPort_OutputMode_pushPull,
            .tx         = &IfxAsclin3_TX_P15_7_OUT,         /* Select the pin for TX connected to the USB port      */
            .txMode     = IfxPort_OutputMode_pushPull,      /* TX pin                                               */
            .pinDriver  = IfxPort_PadDriver_cmosAutomotiveSpeed1
    };
    ascConf.pins = &pins;

    /* FIFO buffers 설정 */
    ascConf.txBuffer = g_uartTxBuffer;                      /* Set the transmission buffer                          */
    ascConf.txBufferSize = ASC_TX_BUFFER_SIZE;              /* Set the transmission buffer size                     */
    ascConf.rxBuffer = g_uartRxBuffer;                      /* Set the receiving buffer                             */
    ascConf.rxBufferSize = ASC_RX_BUFFER_SIZE;              /* Set the receiving buffer size                        */

    /* ASCLIN module 실행
     * Asc, DPipe, Console */
    IfxAsclin_Asc_initModule(&g_ascHandle3, &ascConf);          /* Initialize the module with the given configuration   */

    IfxAsclin_Asc_stdIfDPipeInit(&g_ascStandardInterface, &g_ascHandle3);

    //Ifx_Console_init(&g_ascStandardInterface);

}

// ASCLIN 통해서 송신하기, writing
//void _out_uart3(const unsigned char chr)
//{
//    IfxAsclin_Asc_blockingWrite(&g_ascHandle3, chr);
//}

// ASCLIN 통해서 수신하기, reading
unsigned char _in_uart3(void)
{
    return IfxAsclin_Asc_blockingRead(&g_ascHandle3);
}

void _out_uart3(const unsigned char chr)
{
    while (IfxAsclin_Asc_canWriteCount(&g_ascHandle3, 1, TIME_INFINITE) != TRUE);
    IfxAsclin_Asc_blockingWrite(&g_ascHandle3, chr);
}
